---
id: "mem_896024eb"
topic: "LTM Server Architecture: stdio MCP + HTTP hooks"
tags:
  - architecture
  - mcp
  - hooks
  - container
  - networking
  - stdio
  - http
phase: 0
difficulty: 0.5
created_at: "2026-02-03T19:01:57.871957+00:00"
created_session: 18
---
# LTM Server Connectivity Architecture

The LTM MCP server uses a dual-protocol architecture to support both Claude Code plugin communication and hook-based event tracking.

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                     Container                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              MCP Server (Python)                     │   │
│  │                                                      │   │
│  │   ┌──────────────┐      ┌──────────────────────┐   │   │
│  │   │ stdio MCP    │      │ HTTP Hooks Server    │   │   │
│  │   │ (JSON-RPC)   │      │ (aiohttp on :9999)   │   │   │
│  │   └──────┬───────┘      └──────────┬───────────┘   │   │
│  └──────────┼─────────────────────────┼───────────────┘   │
│             │                         │                     │
└─────────────┼─────────────────────────┼─────────────────────┘
              │                         │
              │ stdin/stdout            │ HTTP POST
              │                         │ (port 9999)
              ▼                         ▼
┌─────────────────────┐    ┌─────────────────────────────┐
│   Claude Code       │    │   Shell Hooks               │
│   (MCP Client)      │    │   - post_tool_use.sh        │
│                     │    │   - session_start.sh        │
│   Tools:            │    │   - pre_compact.sh          │
│   - store_memory    │    │   - session_end.sh          │
│   - recall          │    │                             │
│   - ltm_status      │    │   Read server.json for port │
│   - etc.            │    │   POST to /hook/* endpoints │
└─────────────────────┘    └─────────────────────────────┘
```

## Two Protocols

### 1. stdio (MCP Tools)
- **Purpose**: Claude Code communicates with MCP server via JSON-RPC over stdin/stdout
- **Used by**: Claude Code plugin system
- **Handles**: All MCP tool calls (store_memory, recall, ltm_status, etc.)

### 2. HTTP (Hooks)
- **Purpose**: Shell hooks report events to the server
- **Port**: Dynamic (9900-9999 range), mapped to container's internal port 9999
- **Endpoints**:
  - `POST /hook/session_start` - Initialize session, load memories
  - `POST /hook/track_difficulty` - Count tokens, track tool success/failure
  - `POST /hook/pre_compact` - Handle context compaction
  - `POST /hook/session_end` - Finalize session, run eviction
  - `GET /health` - Health check

## Key Implementation Details

### Container Run Command
```bash
# run-mcp.sh finds an available port and writes server.json
HOOKS_PORT=$(find_available_port)  # 9900-9999 range
echo '{"hooks_port": '$HOOKS_PORT', "hooks_host": "127.0.0.1"}' > server.json

podman run -i --rm \
    -p "127.0.0.1:${HOOKS_PORT}:9999" \
    ltm-mcp-server --with-hooks
```

### `--with-hooks` Flag
- Enables HTTP hooks server alongside stdio MCP
- Server listens on 0.0.0.0:9999 inside container
- run-mcp.sh writes `server.json` with the host port before starting

### server.json
```json
{"hooks_port": 9945, "hooks_host": "127.0.0.1"}
```

Hooks read this file to discover the dynamically allocated host port.

## Why This Architecture?

1. **Claude Code plugins require stdio** - MCP servers must communicate via stdin/stdout
2. **Hooks need HTTP** - Shell scripts can't communicate via stdio with a running process
3. **Single process** - Both protocols run in the same Python process, sharing state
4. **Token counting** - HTTP hooks enable tracking tool responses for token counting
